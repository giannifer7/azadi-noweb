# Core Noweb Implementation Part 1

First, let's see our complete file structure:

````rust
<[@file src/noweb.rs]>=
use regex::Regex;
use std::collections::HashMap;
use std::fs;
use std::io::{self, Write};
use std::path::Path;

use crate::AzadiError;
use crate::SafeFileWriter;

<[error_types]>

<[chunk_store]>

<[chunk_store_implementation]>

<[chunk_writer]>

<[clip_implementation]>
$$
````

Our error handling:

````rust
<[error_types]>=
#[derive(Debug)]
pub enum ChunkError {
    RecursionLimit(String),
    RecursiveReference(String),
    UndefinedChunk(String),
    IoError(io::Error),
}

impl std::fmt::Display for ChunkError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ChunkError::RecursionLimit(chunk) => write!(
                f,
                "Maximum recursion depth exceeded while expanding chunk '{}'",
                chunk
            ),
            ChunkError::RecursiveReference(chunk) => {
                write!(f, "Recursive reference detected in chunk '{}'", chunk)
            }
            ChunkError::UndefinedChunk(chunk) => {
                write!(f, "Referenced chunk '{}' is undefined", chunk)
            }
            ChunkError::IoError(e) => write!(f, "I/O error: {}", e),
        }
    }
}

impl std::error::Error for ChunkError {}

impl From<io::Error> for ChunkError {
    fn from(error: io::Error) -> Self {
        ChunkError::IoError(error)
    }
}

impl From<AzadiError> for ChunkError {
    fn from(err: AzadiError) -> Self {
        ChunkError::IoError(std::io::Error::new(
            std::io::ErrorKind::Other,
            err.to_string(),
        ))
    }
}
$$

Our core data structures:

````rust
<[chunk_store]>=
pub struct ChunkStore {
    chunks: HashMap<String, Chunk>,
    file_chunks: Vec<String>,
    open_re: Regex,
    slot_re: Regex,
    close_re: Regex,
}

#[derive(Debug)]
struct Chunk {
    content: Vec<String>,
    base_indent: usize,
}

impl Chunk {
    fn new(base_indent: usize) -> Self {
        Self {
            content: Vec::new(),
            base_indent,
        }
    }

    fn add_line(&mut self, line: String) {
        self.content.push(line);
    }
}
$$
````

Would you like me to continue with the ChunkStore implementation in a new file? We're approaching the 300-line limit and still have significant implementation to cover.