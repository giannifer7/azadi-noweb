# Complete ChunkStore Implementation

```rust
// Rest of ChunkStore implementation
impl ChunkStore {
    pub fn new(
        open_delim: &str,
        close_delim: &str,
        chunk_end: &str,
        comment_markers: &[String],
    ) -> Self {
        let open_escaped = regex::escape(open_delim);
        let close_escaped = regex::escape(close_delim);

        // Escape each comment marker individually before joining
        let escaped_markers = comment_markers
            .iter()
            .map(|m| regex::escape(m))
            .collect::<Vec<_>>()
            .join("|");

        // Pattern for chunk opening with optional directives in any order
        let open_pattern = format!(
            r"^(\s*)(?:{})?[ \t]*{}(?:@replace[ \t]+)?(?:@file[ \t]+)?([^\s]+){}=",
            escaped_markers,
            open_escaped,
            close_escaped
        );

        // Pattern for chunk reference in content
        let slot_pattern = format!(
            r"(\s*)(?:{})?[ \t]*{}(?:@file[ \t]+)?([^\s]+){}\s*$",
            escaped_markers,
            open_escaped,
            close_escaped
        );

        // Pattern for chunk end marker
        let close_pattern = format!(
            r"^(?:{})?[ \t]*{}\s*$",
            escaped_markers,
            regex::escape(chunk_end)
        );

        ChunkStore {
            chunks: HashMap::new(),
            file_chunks: Vec::new(),
            files: Vec::new(),
            open_re: Regex::new(&open_pattern).expect("Invalid open pattern"),
            slot_re: Regex::new(&slot_pattern).expect("Invalid slot pattern"),
            close_re: Regex::new(&close_pattern).expect("Invalid close pattern"),
        }
    }

    pub fn read(&mut self, text: &str, file: &str) {
        let file_idx = self.get_or_add_file(file);
        let mut chunk_name: Option<String> = None;
        let mut line_number: i32 = -1;

        for line in text.lines() {
            line_number += 1;

            if let Some(captures) = self.open_re.captures(line) {
                let indentation = captures.get(1).map_or("", |m| m.as_str());
                let base_name = captures.get(2).map_or("", |m| m.as_str()).to_string();
                let is_replace = line.contains("@replace");
                let full_name = if line.contains("@file") {
                    format!("@file {}", base_name)
                } else {
                    base_name
                };
                
                if self.validate_chunk_name(&full_name) {
                    if is_replace {
                        self.chunks.remove(&full_name);
                    }
                    
                    chunk_name = Some(full_name.clone());
                    self.chunks.insert(
                        full_name,
                        Chunk::new(indentation.len(), file_idx, line_number as usize),
                    );
                }
                continue;
            }

            if self.close_re.is_match(line) {
                chunk_name = None;
                continue;
            }

            if let Some(ref name) = chunk_name {
                if let Some(chunk) = self.chunks.get_mut(name) {
                    if line.ends_with('\n') {
                        chunk.add_line(line.to_owned());
                    } else {
                        chunk.add_line(format!("{}\n", line));
                    }
                }
            }
        }

        self.file_chunks = self
            .chunks
            .keys()
            .filter(|name| name.starts_with("@file"))
            .map(String::to_owned)
            .collect();
    }

    pub fn expand_with_depth(
        &mut self,
        chunk_name: &str,
        target_indent: &str,
        depth: usize,
        seen: &mut Vec<(String, ChunkLocation)>,
        reference_location: ChunkLocation,
    ) -> Result<Vec<String>, ChunkError> {
        const MAX_DEPTH: usize = 100;
        if depth > MAX_DEPTH {
            return Err(ChunkError::RecursionLimit {
                chunk: chunk_name.to_owned(),
                location: reference_location,
            });
        }

        let chunk_owned = chunk_name.to_owned();
        if seen.iter().any(|(name, _)| name == &chunk_owned) {
            return Err(ChunkError::RecursiveReference {
                chunk: chunk_owned,
                location: reference_location,
            });
        }

        let (content, base_indent, location) = {
            let chunk = match self.chunks.get(chunk_name) {
                Some(chunk) => chunk,
                None => {
                    return Err(ChunkError::UndefinedChunk {
                        chunk: chunk_name.to_owned(),
                        location: reference_location,
                    })
                }
            };
            (
                chunk.content.clone(),
                chunk.base_indent,
                chunk.location,
            )
        };

        if let Some(chunk) = self.chunks.get_mut(chunk_name) {
            chunk.increment_references();
        }

        seen.push((chunk_owned, reference_location));

        let mut result = Vec::new();
        let mut current_line = 0;

        for line in &content {
            current_line += 1;
            match self.slot_re.captures(line) {
                Some(captures) => {
                    let additional_indent = captures.get(1).map_or("", |m| m.as_str());
                    let referenced_chunk = captures.get(2).map_or("", |m| m.as_str());

                    let relative_indent = if additional_indent.len() > base_indent {
                        &additional_indent[base_indent..]
                    } else {
                        ""
                    };

                    let new_indent = if target_indent.is_empty() {
                        relative_indent.to_owned()
                    } else {
                        format!("{}{}", target_indent, relative_indent)
                    };

                    let expansion_location = ChunkLocation {
                        file_idx: location.file_idx,
                        line: location.line + current_line - 1,
                    };

                    let expanded = self.expand_with_depth(
                        referenced_chunk.trim(),
                        &new_indent,
                        depth + 1,
                        seen,
                        expansion_location,
                    )?;
                    result.extend(expanded);
                }
                None => {
                    let line_indent = if line.len() > base_indent {
                        &line[base_indent..]
                    } else {
                        line
                    };

                    if target_indent.is_empty() {
                        result.push(line_indent.to_owned());
                    } else {
                        result.push(format!("{}{}", target_indent, line_indent));
                    }
                }
            };
        }

        seen.pop();
        Ok(result)
    }

    pub fn expand(&mut self, chunk_name: &str, indent: &str) -> Result<Vec<String>, ChunkError> {
        let mut seen = Vec::new();
        let initial_location = ChunkLocation {
            file_idx: self.get_or_add_file("<root>"),
            line: 0,
        };
        self.expand_with_depth(chunk_name, indent, 0, &mut seen, initial_location)
    }

    pub fn get_chunk_content(&mut self, chunk_name: &str) -> Result<Vec<String>, ChunkError> {
        self.expand(chunk_name, "")
    }

    pub fn get_file_chunks(&self) -> &[String] {
        &self.file_chunks
    }

    pub fn reset(&mut self) {
        self.chunks.clear();
        self.file_chunks.clear();
        self.files.clear();
    }

    pub fn has_chunk(&self, name: &str) -> bool {
        self.chunks.contains_key(name)
    }
}
```
